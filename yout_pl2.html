<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>YouTube Player + Transcript (yout_pl2)</title>
  <style>
    body {
      margin: 0;
      padding: 16px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      line-height: 1.4;
    }

    h1 { margin: 0 0 12px; font-size: 20px; }

    #playerWrap { max-width: 980px; }
    #player { aspect-ratio: 16 / 9; width: 100%; }

    .row {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin: 12px 0;
      align-items: center;
    }

    /* Main control row: keep all buttons on one line */
    .row.controls {
      flex-wrap: nowrap;
    }

    /* Fixed width to prevent layout jump when label changes Play <-> Pause */
    #btnPlay {
      width: 92px;
      text-align: center;
    }

    /* Top-right main menu button */
    #btnMainMenu {
      position: fixed;
      top: 12px;
      right: 12px;
      z-index: 50;
    }

    button {
      padding: 10px 12px;
      min-height: 44px;
      border: 1px solid currentColor;
      border-radius: 10px;
      background: transparent;
      cursor: pointer;
    }

    button:disabled { opacity: 0.6; cursor: default; }

    #t {
      font-variant-numeric: tabular-nums;
      min-width: 72px;
      display: inline-block;
    }

    #transWrap {
      display: none;
      max-width: 980px;
      margin-top: 10px;
      border: 1px solid currentColor;
      border-radius: 12px;
      padding: 10px;
      /* Fixed-height, scrollable transcript panel (prevents active line “disappearing”) */
      height: 60vh;
      max-height: 520px;
      min-height: 320px;
      overflow-y: auto;
    }

    #transList {
      list-style: none;
      padding: 0;
      margin: 0;
      display: grid;
      gap: 6px;
      /* Give some breathing room so borders are not clipped at edges */
      padding-top: 8px;
      padding-bottom: 24px;
    }

    #transList li {
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid transparent;
      cursor: pointer;
      user-select: none;
    }

    #transList li[data-active="1"] {
      background-color: color-mix(in srgb, currentColor 14%, transparent);
    }

    /* Mark1 highlighting (visible after load from Firebase too) */
    #transList li[data-mark1="1"] {
      background-color: color-mix(in srgb, currentColor 9%, transparent);
    }

    /* Active + Mark1: slightly stronger tint */
    #transList li[data-active="1"][data-mark1="1"] {
      background-color: color-mix(in srgb, currentColor 18%, transparent);
    }

    #transList small {
      opacity: 0.75;
      margin-right: 8px;
    }

    /* Two-line transcript layout (lang1 + lang2) */
    #transList .trLine {
      display: flex;
      gap: 8px;
      align-items: baseline;
    }

    #transList .trLine2 {
      margin-left: 40px; /* visually align under the text, not under timestamp */
    }

    /* Language selector (Menu header row) */
    #langRow button[data-selected="1"] {
      background-color: color-mix(in srgb, currentColor 14%, transparent);
    }

    dialog {
      width: min(980px, calc(100vw - 24px));
      border: 1px solid currentColor;
      border-radius: 12px;
      padding: 12px;
    }

    dialog::backdrop {
      background: rgba(0, 0, 0, 0.4);
    }

    textarea {
      width: 100%;
      box-sizing: border-box;
      border: 1px solid currentColor;
      border-radius: 10px;
      padding: 10px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: 13px;
      line-height: 1.4;
    }

    .muted { opacity: 0.75; }
  </style>
</head>
<body> 

  <button id="btnMainMenu">Menu</button>

  <div id="playerWrap">
    <div id="player"></div>
  </div>

  <div class="row controls">
    <button id="btnPlay">Play</button>
    <button id="btnMark1">Mark1</button>
    <button id="btnMrkOff">MrkOFF</button>
    <span id="timeWrap" style="display:none;">Time: <span id="t">0.00</span>s</span>
    <button id="btnMenu" style="margin-left:auto;">Menu</button>
  </div>

  <div id="transWrap">
    <ul id="transList"></ul>
  </div>

  <dialog id="dlgMenu">
    <form method="dialog">
      <h3 style="margin:0 0 8px; font-size:16px;">Menu</h3>
      <div id="langRow" class="row" style="margin:0 0 8px;"></div>
      <div class="row" style="margin:8px 0 0;">
        <button id="btnMenuPaste" value="cancel">Paste transcript</button>
        <button id="btnMenuToggleTrans" value="cancel">Hide transcription</button>
        <button id="btnMenuToggleTime" value="cancel">Show time</button>
        <button value="cancel">Close</button>
      </div>
    </form>
  </dialog>

  <dialog id="dlgTrans">
    <form method="dialog">
      <h3 style="margin:0 0 8px; font-size:16px;">Paste transcript text</h3>
      <div id="transLangInfo" class="muted" style="margin-bottom:6px;"></div>
      <div class="muted" style="margin-bottom:8px;">
        Paste lines like <code>0:04</code> then the text line(s). This will be parsed into {t,text} items and stored for this video.
      </div>
      <textarea id="taTrans" rows="14" placeholder="0:01
[Music]
0:04
Hi everyone. Welcome back...
0:06
English Channel..."></textarea>
      <div class="row" style="margin:10px 0 0;">
        <button id="btnApplyTrans" value="cancel">Apply</button>
        <button id="btnSaveTrans" value="cancel">Save to Firebase</button>
        <button value="cancel">Close</button>
        <span id="transStatus" class="muted"></span>
      </div>
    </form>
  </dialog>

  <!-- Firebase auth + RTDB request helper (defines GlobalVars / URL_DataSet) -->
   
  <script src="./yout_pl2/yu2_global_var.js"></script>
  <script src="./yout_pl2/youtube_transcript_store.js"></script>
  <script src="./yout_pl2/youtube_ref_videos_store.js"></script>

  <dialog id="dlgMainMenu">
    <form method="dialog">
      <h3 style="margin:0 0 8px; font-size:16px;">YouTube menu</h3>
      <div class="row" style="margin:8px 0 0;">
        <button id="btnAddVideo" value="cancel">Add YouTube link</button>
        <button value="cancel">Close</button>
      </div>
      <div class="muted" style="margin-top:6px;">First 5 videos (sorted by order)</div>
      <ul id="refVideosList" style="list-style:none; padding:0; margin:10px 0 0; display:grid; gap:6px;"></ul>
      <div id="refVideosStatus" class="muted" style="margin-top:8px;"></div>
    </form>
  </dialog>

  <dialog id="dlgAddVideo">
    <form method="dialog" id="frmAddVideo">
      <h3 style="margin:0 0 8px; font-size:16px;">Add YouTube link</h3>
      <div class="muted" style="margin-bottom:8px;">Fill URL; indent_id (videoId) can be auto-detected.</div>

      <div style="display:grid; gap:8px;">
        <label>indent_id (optional)
          <input id="inIndentId" style="width:100%; box-sizing:border-box; padding:10px; border:1px solid currentColor; border-radius:10px;" />
        </label>
        <label>url
          <input id="inUrl" placeholder="https://youtu.be/maKy1pRdcDw" style="width:100%; box-sizing:border-box; padding:10px; border:1px solid currentColor; border-radius:10px;" required />
        </label>
        <label>short_name (optional)
          <input id="inShortName" style="width:100%; box-sizing:border-box; padding:10px; border:1px solid currentColor; border-radius:10px;" />
        </label>
        <label>title (optional)
          <input id="inTitle" style="width:100%; box-sizing:border-box; padding:10px; border:1px solid currentColor; border-radius:10px;" />
        </label>
        <label>tag (optional)
          <input id="inTag" style="width:100%; box-sizing:border-box; padding:10px; border:1px solid currentColor; border-radius:10px;" />
        </label>
        <label>order (number)
          <input id="inOrder" type="number" value="9999" style="width:100%; box-sizing:border-box; padding:10px; border:1px solid currentColor; border-radius:10px;" />
        </label>
        <label>description (optional)
          <textarea id="inDesc" rows="3" style="width:100%; box-sizing:border-box; padding:10px; border:1px solid currentColor; border-radius:10px;"></textarea>
        </label>
      </div>

      <div class="row" style="margin:10px 0 0;">
        <button id="btnSaveVideo" value="cancel">Save</button>
        <button value="cancel">Close</button>
        <span id="addVideoStatus" class="muted"></span>
      </div>
    </form>
  </dialog>

  <script>
    // 1) Load YouTube IFrame API
    const tag = document.createElement('script');
    tag.src = 'https://www.youtube.com/iframe_api';
    document.head.appendChild(tag);

    // Current video
    let currentVideoId = 'maKy1pRdcDw';

    // Transcript items:
    // - legacy: { t: seconds, text: string }
    // - multi-lang: { t: seconds, text_sv/text_en/text_uk..., Mark1?: boolean }
    let transcript = [];

    // Keep rawText if loaded from Firebase (so Mark1 updates can be saved without losing rawText)
    let transcriptRawText = '';

    // Multi-language transcript settings
    const LANG_ROOT_PATH = '../db_youtube2/ref_languages_set';
    const UI_STATE_PATH = '../db_youtube2/ui_state/yout_pl2';
    let langEdit = 'sv';
    let lang1Show = 'sv';
    let lang2Show = 'en';

    let player = null;
    let activeIndex = -1;

    let isPlaying = false;

    // When restoring saved UI state, suppress auto-scroll briefly so updateActiveRow()
    // does not override the restored scroll position.
    let _suppressAutoScrollUntilMs = 0;

    function setStatus(msg) {
      const el = document.getElementById('transStatus');
      if (!el) return;
      el.textContent = msg || '';
    }

    function setRefStatus(msg) {
      const el = document.getElementById('refVideosStatus');
      if (!el) return;
      el.textContent = msg || '';
    }

    function setAddVideoStatus(msg) {
      const el = document.getElementById('addVideoStatus');
      if (!el) return;
      el.textContent = msg || '';
    }

    function setMainStatus(msg) {
      // Keep it minimal: reuse the status field in the transcript paste dialog if available.
      // (No new UI elements requested.)
      setStatus(msg);
    }

    function ytNowIso() {
      try { return new Date().toISOString(); } catch { return String(Date.now()); }
    }

    function cleanLangCode(x) {
      const s = cleanStr(x).toLowerCase();
      if (!s) return '';
      if (!/^[a-z0-9_-]{2,16}$/.test(s)) return '';
      return s;
    }

    function ytEnsureGv() {
      if (window.gv && window.gv.URL_DS) return window.gv;
      const GVClass = (typeof GlobalVars === 'function')
        ? GlobalVars
        : (typeof globalThis !== 'undefined' && typeof globalThis.GlobalVars === 'function')
          ? globalThis.GlobalVars
          : (typeof window.GlobalVars === 'function')
            ? window.GlobalVars
            : null;
      if (GVClass) {
        const gv = new GVClass();
        window.gv = gv;
        return gv;
      }
      throw new Error('GlobalVars is not available (load ./yout_pl2/yu2_global_var.js first)');
    }

    async function ytEnsureSignedIn() {
      const gv = ytEnsureGv();
      if (gv.URL_DS && gv.URL_DS.idToken) return;
      if (typeof gv.SignIn_User !== 'function') throw new Error('gv.SignIn_User missing');
      await gv.SignIn_User();
    }

    function ytRequestByPath(addurl, method = 'GET', body = null) {
      return new Promise((resolve, reject) => {
        try {
          const gv = ytEnsureGv();
          const ObjRequest = gv.URL_DS.GetObjForRequest();
          ObjRequest.addUrl = addurl;
          ObjRequest.ametod = method;
          ObjRequest.vobj = body;
          ObjRequest.CallBackFunction = function(vdata) { resolve(vdata); };
          ObjRequest.ErrorCallback = function(err) { reject(err || new Error('request failed')); };
          gv.URL_DS.requestData_By_URL_Path(ObjRequest);
        } catch (e) {
          reject(e);
        }
      });
    }

    function normalizeLanguagesSet(data) {
      const rawLangs = (data && typeof data === 'object') ? data.languages : null;
      const list = [];
      if (rawLangs && typeof rawLangs === 'object') {
        for (const [k, v] of Object.entries(rawLangs)) {
          const code = cleanLangCode(v && v.code ? v.code : k);
          if (!code) continue;
          const label = cleanStr((v && v.label) || code.toUpperCase());
          const order = Number.isFinite(Number(v && v.order)) ? Number(v.order) : 9999;
          list.push({ code, label, order });
        }
      }
      list.sort((a, b) => (a.order - b.order) || a.code.localeCompare(b.code));
      return list;
    }

    async function loadOrSeedLanguagesSet() {
      await ytEnsureSignedIn();
      let data = null;
      try {
        data = await ytRequestByPath(LANG_ROOT_PATH, 'GET');
      } catch {
        data = null;
      }

      let list = normalizeLanguagesSet(data);
      if (list.length === 0) {
        const payload = {
          updatedAt: ytNowIso(),
          languages: {
            sv: { code: 'sv', label: 'SV', order: 1 },
            en: { code: 'en', label: 'EN', order: 2 },
            uk: { code: 'uk', label: 'UK', order: 3 }
          }
        };
        await ytRequestByPath(LANG_ROOT_PATH, 'PUT', payload);
        list = normalizeLanguagesSet(payload);
      }
      return list;
    }

    async function saveLastSelectedVideoId(videoId) {
      const vid = cleanStr(videoId);
      if (!vid) return;
      try {
        await ytEnsureSignedIn();
        await ytRequestByPath(`${UI_STATE_PATH}/last_selected_video`, 'PUT', {
          videoId: vid,
          updatedAt: ytNowIso()
        });
      } catch {
        // ignore (page should work without firebase)
      }
    }

    async function loadLastSelectedVideoId() {
      try {
        await ytEnsureSignedIn();
        const data = await ytRequestByPath(`${UI_STATE_PATH}/last_selected_video`, 'GET');
        const vid = cleanStr(data && data.videoId);
        return vid || '';
      } catch {
        return '';
      }
    }

    // ------------------------------
    // Transcript UI persistence (scroll + time)
    // ------------------------------
    // Store transcript scroll position and last playback time per selected videoId under:
    // ../db_youtube2/ref_youtube_videos/<encodedVideoId>/transListScroll
    //
    // Note: the scroll container is #transWrap (not #transList) in the current UI.
    // We still fallback to #transList if needed.
    const TRANS_SCROLL_SAVE_MIN_MS = 30 * 1000;
    let _lastScrollSavedAtMs = 0;
    let _lastScrollSavedTop = null;
    let _lastTimeSavedSec = null;

    function getTranscriptScrollContainer() {
      return document.getElementById('transWrap') || document.getElementById('transList');
    }

    function getRefVideosRootPath() {
      return (window.YouTubeRefVideosStore && window.YouTubeRefVideosStore.ROOT_PATH)
        ? window.YouTubeRefVideosStore.ROOT_PATH
        : '../db_youtube2/ref_youtube_videos';
    }

    function encodeRefVideoKey(videoId) {
      const vid = cleanStr(videoId);
      if (!vid) return '';
      if (window.YouTubeRefVideosStore && typeof window.YouTubeRefVideosStore.encodeKey === 'function') {
        try { return window.YouTubeRefVideosStore.encodeKey(vid); } catch { return ''; }
      }
      // Fallback: store directly (less safe for special chars, but videoId is safe)
      return vid;
    }

    function getPlayerTimeSec() {
      try {
        if (!player || typeof player.getCurrentTime !== 'function') return null;
        const t = Number(player.getCurrentTime() || 0);
        return Number.isFinite(t) ? Math.max(0, t) : null;
      } catch {
        return null;
      }
    }

    async function saveTranscriptScrollPosition() {
      try {
        const vid = cleanStr(currentVideoId);
        if (!vid) return;

        const el = getTranscriptScrollContainer();
        if (!el) return;

        const top = Number(el.scrollTop || 0);
        if (!Number.isFinite(top)) return;

  const tSec = getPlayerTimeSec();

  // Save no more often than every 30s, and only if something changed.
        const nowMs = Date.now();
        if (_lastScrollSavedAtMs && (nowMs - _lastScrollSavedAtMs) < TRANS_SCROLL_SAVE_MIN_MS) return;

  const topChanged = !(_lastScrollSavedTop != null && Math.abs(top - _lastScrollSavedTop) < 1);
  const timeChanged = !(tSec != null && _lastTimeSavedSec != null && Math.abs(tSec - _lastTimeSavedSec) < 0.25);
  if (!topChanged && !timeChanged) return;

        const key = encodeRefVideoKey(vid);
        if (!key) return;

        await ytEnsureSignedIn();
        const root = getRefVideosRootPath();
        await ytRequestByPath(`${root}/${key}/transListScroll`, 'PUT', {
          top: Math.max(0, Math.round(top)),
          t: (tSec == null) ? null : Math.max(0, Number(tSec)),
          updatedAt: ytNowIso()
        });

        _lastScrollSavedAtMs = nowMs;
        _lastScrollSavedTop = top;
        if (tSec != null) _lastTimeSavedSec = tSec;
      } catch {
        // ignore (page should work without firebase)
      }
    }

    function parseScrollTopFromDbValue(v) {
      if (v == null) return null;
      if (typeof v === 'number' && Number.isFinite(v)) return Math.max(0, v);
      if (typeof v === 'string') {
        const n = Number(v);
        if (Number.isFinite(n)) return Math.max(0, n);
      }
      if (typeof v === 'object') {
        const n = Number(v.top ?? v.scrollTop ?? v.scroll_top);
        if (Number.isFinite(n)) return Math.max(0, n);
      }
      return null;
    }

    function parseTimeSecFromDbValue(v) {
      if (v == null) return null;
      if (typeof v === 'number' && Number.isFinite(v)) return Math.max(0, v);
      if (typeof v === 'string') {
        const n = Number(v);
        if (Number.isFinite(n)) return Math.max(0, n);
      }
      if (typeof v === 'object') {
        const n = Number(v.t ?? v.time ?? v.timeSec ?? v.sec ?? v.seconds);
        if (Number.isFinite(n)) return Math.max(0, n);
      }
      return null;
    }

    function sleepMs(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    async function seekPlayerToTimeSec(tSec) {
      const t = Number(tSec);
      if (!Number.isFinite(t)) return;
      for (let i = 0; i < 20; i++) {
        try {
          if (player && typeof player.seekTo === 'function') {
            player.seekTo(Math.max(0, t), true);
            return;
          }
        } catch {}
        await sleepMs(100);
      }
    }

    async function restoreTranscriptScrollPosition(videoId) {
      try {
        const vid = cleanStr(videoId);
        if (!vid) return;
        const key = encodeRefVideoKey(vid);
        if (!key) return;

        await ytEnsureSignedIn();
        const root = getRefVideosRootPath();
        const data = await ytRequestByPath(`${root}/${key}/transListScroll`, 'GET');
        const top = parseScrollTopFromDbValue(data);

        const tSec = parseTimeSecFromDbValue(data);
        if (tSec != null) {
          await seekPlayerToTimeSec(tSec);
          // If transcript exists, set active line to the saved time.
          try {
            const idx = findActiveByTime(tSec);
            if (typeof idx === 'number' && idx >= 0) {
              _suppressAutoScrollUntilMs = Date.now() + 5000;
              setActiveIndex(idx);
            }
          } catch {}
        }

        if (top == null) return;

        // Apply after transcript has been rendered; retry a few times in case
        // render is delayed (lazy render or async transcript load).
        for (let i = 0; i < 12; i++) {
          const el = getTranscriptScrollContainer();
          if (el) {
            _suppressAutoScrollUntilMs = Date.now() + 5000;
            try { el.scrollTo({ top, behavior: 'auto' }); } catch { try { el.scrollTop = top; } catch {} }
            break;
          }
          await sleepMs(50);
        }

        _lastScrollSavedTop = top;
        if (tSec != null) _lastTimeSavedSec = tSec;
      } catch {
        // ignore
      }
    }

    function setLangEdit(nextLang) {
      const code = cleanLangCode(nextLang);
      if (!code) return;
      langEdit = code;
      const row = document.getElementById('langRow');
      if (!row) return;
      row.querySelectorAll('button[data-lang]').forEach(btn => {
        btn.dataset.selected = (btn.dataset.lang === langEdit) ? '1' : '0';
      });

      updateTransLangInfo();
    }

    function updateTransLangInfo() {
      const el = document.getElementById('transLangInfo');
      if (!el) return;
      const edit = cleanLangCode(langEdit);
      const l1 = cleanLangCode(lang1Show);
      const l2 = cleanLangCode(lang2Show);
      const show = l2 && l2 !== l1 ? `${(l1 || '').toUpperCase()} + ${(l2 || '').toUpperCase()}` : (l1 || '').toUpperCase();
      el.textContent = `Edit language: ${(edit || '').toUpperCase()} | Show: ${show || '—'}`;
    }

    function renderLanguageButtons(list) {
      const row = document.getElementById('langRow');
      if (!row) return;
      row.innerHTML = '';

      if (!Array.isArray(list) || list.length === 0) {
        const span = document.createElement('span');
        span.className = 'muted';
        span.textContent = 'No languages set';
        row.appendChild(span);
        return;
      }

      list.forEach(l => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.dataset.lang = l.code;
        btn.dataset.selected = (l.code === langEdit) ? '1' : '0';
        btn.textContent = l.label || l.code.toUpperCase();
        btn.addEventListener('click', (e) => {
          e.preventDefault();
          setLangEdit(l.code);
        });
        row.appendChild(btn);
      });
    }

    function applyTranscriptMetaFromData(data) {
      const l1 = cleanLangCode(data && data.lang1_show);
      const l2 = cleanLangCode(data && data.lang2_show);
      if (l1) lang1Show = l1;
      if (l2) lang2Show = l2;

      updateTransLangInfo();
    }

    function getRowText(row, langCode) {
      const code = cleanLangCode(langCode);
      if (row && code) {
        const v = row[`text_${code}`];
        if (typeof v === 'string' && v.trim()) return v.trim();
      }
      const legacy = row && row.text;
      if (typeof legacy === 'string' && legacy.trim()) return legacy.trim();
      return '';
    }

    function mergeTranscriptLanguage(existingItems, parsedItems, langCode) {
      const code = cleanLangCode(langCode);
      if (!code) return Array.isArray(existingItems) ? existingItems : [];

      const base = Array.isArray(existingItems) ? existingItems.slice() : [];
      const byT = new Map();
      base.forEach(row => {
        const t = Number(row && row.t);
        if (Number.isFinite(t)) byT.set(t, row);
      });

      const parsed = Array.isArray(parsedItems) ? parsedItems : [];
      parsed.forEach(p => {
        const t = Number(p && p.t);
        const text = cleanStr(p && p.text);
        if (!Number.isFinite(t) || !text) return;

        let row = byT.get(t);
        if (!row) {
          row = { t };
          base.push(row);
          byT.set(t, row);
        }
        row[`text_${code}`] = text;
      });

      base.sort((a, b) => Number(a.t || 0) - Number(b.t || 0));
      return base;
    }

    function parseTimeToSeconds(s) {
      const raw = (s == null) ? '' : String(s).trim();
      if (!raw) return null;
      // Accept: m:ss, mm:ss, h:mm:ss
      const m = /^(\d+):(\d{2})(?::(\d{2}))?$/.exec(raw);
      if (!m) return null;
      const a = Number(m[1]);
      const b = Number(m[2]);
      const c = (m[3] != null) ? Number(m[3]) : null;
      if (Number.isNaN(a) || Number.isNaN(b) || (c != null && Number.isNaN(c))) return null;
      if (c == null) return (a * 60) + b;
      return (a * 3600) + (b * 60) + c;
    }

    function parseTranscriptText(rawText) {
      const raw = (rawText == null) ? '' : String(rawText);
      const lines = raw.split(/\r?\n/).map(l => l.trim());
      const items = [];
      let cur = null;
      for (const line of lines) {
        if (!line) continue;
        const t = parseTimeToSeconds(line);
        if (t != null) {
          cur = { t, text: '' };
          items.push(cur);
          continue;
        }
        if (!cur) continue;
        // append text to current timestamp
        cur.text = cur.text ? (cur.text + ' ' + line) : line;
      }

      // Normalize: drop empty entries, sort, merge duplicates
      const cleaned = items
        .filter(it => it && typeof it.t === 'number' && isFinite(it.t) && String(it.text || '').trim())
        .map(it => ({ t: Number(it.t), text: String(it.text || '').trim() }))
        .sort((a, b) => a.t - b.t);

      const merged = [];
      for (const it of cleaned) {
        const last = merged[merged.length - 1];
        if (last && last.t === it.t) {
          last.text = (last.text + ' ' + it.text).trim();
        } else {
          merged.push(it);
        }
      }
      return merged;
    }

    function setTranscript(items) {
      transcript = Array.isArray(items) ? items : [];
      // if transcript panel already rendered, re-render
      const wrap = document.getElementById('transWrap');
      if (wrap && wrap.dataset.rendered) {
        renderTranscript();
      }
      if (transcript.length > 0) {
        setActiveIndex(0);
      } else {
        activeIndex = -1;
        updateActiveRow();
      }
    }

    function fmtTimestamp(seconds) {
      const total = Math.max(0, Math.floor(Number(seconds || 0)));
      if (!isFinite(total)) return '0:00';
      const s = total % 60;
      const totalMin = Math.floor(total / 60);
      const m = totalMin % 60;
      const h = Math.floor(totalMin / 60);
      const s2 = String(s).padStart(2, '0');
      if (h > 0) {
        const m2 = String(m).padStart(2, '0');
        return `${h}:${m2}:${s2}`;
      }
      return `${totalMin}:${s2}`;
    }

    function setActiveIndex(idx) {
      if (!Array.isArray(transcript) || transcript.length === 0) {
        activeIndex = -1;
        updateActiveRow();
        return;
      }
      const next = Math.max(0, Math.min(transcript.length - 1, idx));
      activeIndex = next;
      updateActiveRow();
    }

    function updateActiveRow() {
      const list = document.getElementById('transList');
      const wrap = document.getElementById('transWrap');
      const items = list.querySelectorAll('li');
      items.forEach((li, i) => {
        li.dataset.active = (i === activeIndex) ? '1' : '0';
      });
      if (!wrap) return;
      if (wrap.style.display !== 'block') return;
      if (activeIndex < 0 || !items[activeIndex]) return;

      // Avoid fighting restored scroll state.
      try {
        if (_suppressAutoScrollUntilMs && Date.now() < _suppressAutoScrollUntilMs) return;
      } catch {}

      // Keep current line around “line 3” (near top) to avoid it drifting to the bottom.
      try {
        const activeEl = items[activeIndex];
        const wrapRect = wrap.getBoundingClientRect();
        const activeRect = activeEl.getBoundingClientRect();

        // Approximate one “line height” including spacing.
        const lineStep = Math.max(1, activeEl.offsetHeight + 6);

        // Where the active line should appear: after ~2 lines from the top.
        const desiredTopPx = wrapRect.top + (2 * lineStep);

        const delta = activeRect.top - desiredTopPx;
        // Adjust scrollTop by delta (positive delta means active is too low).
        const nextTop = Math.max(0, wrap.scrollTop + delta);
        wrap.scrollTo({ top: nextTop, behavior: 'auto' });
      } catch {}
    }

    function findActiveByTime(t) {
      if (!Array.isArray(transcript) || transcript.length === 0) return -1;
      let idx = 0;
      for (let i = 0; i < transcript.length; i++) {
        const cur = transcript[i];
        const next = transcript[i + 1];
        const start = Number(cur.t || 0);
        const end = next ? Number(next.t || 0) : Number.POSITIVE_INFINITY;
        if (t >= start && t < end) {
          idx = i;
          break;
        }
      }
      return idx;
    }

    function seekToTranscriptIndex(idx) {
      if (!player || typeof player.seekTo !== 'function') return;
      const row = transcript[idx];
      if (!row) return;
      const t = Number(row.t || 0);
      player.seekTo(Math.max(0, t), true);
      setActiveIndex(idx);
    }

    function renderTranscript() {
      const list = document.getElementById('transList');
      list.innerHTML = '';
      if (!Array.isArray(transcript) || transcript.length === 0) {
        const li = document.createElement('li');
        li.dataset.active = '0';
        li.dataset.mark1 = '0';
        li.className = 'muted';
        li.textContent = 'No transcript loaded yet. Use “Paste transcript”.';
        list.appendChild(li);
        activeIndex = -1;
        updateActiveRow();
        return;
      }

      // Preserve active index across re-renders when possible.
      const prevActive = activeIndex;

      transcript.forEach((row, idx) => {
        const li = document.createElement('li');
        li.dataset.idx = String(idx);
        li.dataset.active = '0';
        li.dataset.mark1 = row && row.Mark1 ? '1' : '0';

        const line1 = getRowText(row, lang1Show);
        const showSecond = !!cleanLangCode(lang2Show) && cleanLangCode(lang2Show) !== cleanLangCode(lang1Show);
        const line2 = showSecond ? getRowText(row, lang2Show) : '';

        const div1 = document.createElement('div');
        div1.className = 'trLine';
        const sm = document.createElement('small');
        sm.textContent = fmtTimestamp(row.t);
        const sp1 = document.createElement('span');
        sp1.textContent = line1;
        div1.appendChild(sm);
        div1.appendChild(sp1);
        li.appendChild(div1);

        if (showSecond) {
          const div2 = document.createElement('div');
          div2.className = 'trLine trLine2';
          const sp2 = document.createElement('span');
          sp2.textContent = line2;
          div2.appendChild(sp2);
          li.appendChild(div2);
        }
        li.addEventListener('click', () => seekToTranscriptIndex(idx));
        list.appendChild(li);
      });

      if (typeof prevActive === 'number' && prevActive >= 0 && prevActive < transcript.length) {
        setActiveIndex(prevActive);
      } else {
        setActiveIndex(0);
      }
    }

    function setTranscriptVisible(isVisible) {
      const wrap = document.getElementById('transWrap');
      wrap.style.display = isVisible ? 'block' : 'none';
      if (isVisible) {
        // Lazy render
        if (!wrap.dataset.rendered) {
          renderTranscript();
          wrap.dataset.rendered = '1';
        }

        // Best-effort: when opening transcript panel, restore last saved time + UI scroll.
        Promise.resolve().then(() => restoreTranscriptScrollPosition(currentVideoId)).catch(() => {});
      }
    }

    function toggleTranscript() {
      const wrap = document.getElementById('transWrap');
      const isOpen = wrap.style.display === 'block';
      setTranscriptVisible(!isOpen);
    }

    function setTimeVisible(isVisible) {
      const el = document.getElementById('timeWrap');
      if (!el) return;
      el.style.display = isVisible ? 'inline' : 'none';
    }

    function isTimeVisible() {
      const el = document.getElementById('timeWrap');
      return !!el && el.style.display !== 'none';
    }

    function updateMenuLabels() {
      const btnTrans = document.getElementById('btnMenuToggleTrans');
      const btnTime = document.getElementById('btnMenuToggleTime');
      const wrap = document.getElementById('transWrap');
      const transVisible = wrap && wrap.style.display === 'block';
      if (btnTrans) btnTrans.textContent = transVisible ? 'Hide transcription' : 'Show transcription';
      if (btnTime) btnTime.textContent = isTimeVisible() ? 'Hide time' : 'Show time';
    }

    function openPasteModal() {
      setStatus('');
      const dlg = document.getElementById('dlgTrans');
      if (!dlg) return;
      updateTransLangInfo();
      if (typeof dlg.showModal === 'function') dlg.showModal();
      else dlg.setAttribute('open', 'open');
    }

    async function saveTranscriptToFirebase(rawText, items) {
      if (!window.YouTubeTranscriptStore || typeof window.YouTubeTranscriptStore.save !== 'function') {
        throw new Error('YouTubeTranscriptStore not available');
      }
      await window.YouTubeTranscriptStore.save(currentVideoId, items, rawText, {
        lang1_show: lang1Show,
        lang2_show: lang2Show
      });
    }

    async function tryLoadTranscriptFromFirebase() {
      if (!window.YouTubeTranscriptStore || typeof window.YouTubeTranscriptStore.load !== 'function') return;
      try {
        const data = await window.YouTubeTranscriptStore.load(currentVideoId);
        const items = (data && Array.isArray(data.items)) ? data.items : [];
        transcriptRawText = (data && typeof data.rawText === 'string') ? data.rawText : '';
        applyTranscriptMetaFromData(data);
        if (items && items.length) {
          setTranscript(items);
        }
      } catch {
        // silent; page should work without firebase
      }
    }

    function updatePlayButtonLabel() {
      const btn = document.getElementById('btnPlay');
      if (!btn) return;
      btn.textContent = isPlaying ? 'Pause' : 'Play';
    }

    function togglePlayPause() {
      if (!player) return;
      if (isPlaying && typeof player.pauseVideo === 'function') player.pauseVideo();
      else if (!isPlaying && typeof player.playVideo === 'function') player.playVideo();
    }

    async function setMark1OnActive(nextValue) {
      if (!Array.isArray(transcript) || transcript.length === 0) {
        setMainStatus('No transcript loaded');
        return;
      }
      if (activeIndex < 0 || activeIndex >= transcript.length) {
        setMainStatus('No active line');
        return;
      }

      const row = transcript[activeIndex];
      if (!row) return;

      row.Mark1 = !!nextValue;
      renderTranscript();
      setActiveIndex(activeIndex);

      // Persist immediately so the flag is not lost.
      try {
        setMainStatus('Saving Mark1...');
        await saveTranscriptToFirebase(transcriptRawText, transcript);
        setMainStatus(row.Mark1 ? 'Mark1 saved (true)' : 'Mark1 saved (false)');
      } catch (e) {
        setMainStatus('Mark1 save failed (check console)');
        try { console.warn('Mark1 save failed', e); } catch {}
      }
    }

    async function toggleMark1OnActive() {
      if (!Array.isArray(transcript) || transcript.length === 0) {
        setMainStatus('No transcript loaded');
        return;
      }
      if (activeIndex < 0 || activeIndex >= transcript.length) {
        setMainStatus('No active line');
        return;
      }
      const row = transcript[activeIndex];
      if (!row) return;
      await setMark1OnActive(!row.Mark1);
    }

    function openMenuModal() {
      const dlg = document.getElementById('dlgMenu');
      if (!dlg) return;
      updateMenuLabels();

      // Load/seed languages set and render language buttons in the menu header.
      Promise.resolve().then(async () => {
        try {
          const list = await loadOrSeedLanguagesSet();
          renderLanguageButtons(list);
          if (list.length && !list.some(l => l.code === langEdit)) setLangEdit(list[0].code);
        } catch {
          renderLanguageButtons([]);
        }
      }).catch(() => {});

      if (typeof dlg.showModal === 'function') dlg.showModal();
      else dlg.setAttribute('open', 'open');
    }

    function openMainMenu() {
      const dlg = document.getElementById('dlgMainMenu');
      if (!dlg) return;
      setRefStatus('Loading...');
      Promise.resolve().then(() => loadRefVideos()).catch(() => setRefStatus('Load failed'));
      if (typeof dlg.showModal === 'function') dlg.showModal();
      else dlg.setAttribute('open', 'open');
    }

    function openAddVideoDialog() {
      setAddVideoStatus('');
      const dlg = document.getElementById('dlgAddVideo');
      if (!dlg) return;
      if (typeof dlg.showModal === 'function') dlg.showModal();
      else dlg.setAttribute('open', 'open');
    }

    function closeDialogById(id) {
      const dlg = document.getElementById(id);
      if (!dlg) return;
      try {
        if (typeof dlg.close === 'function') dlg.close();
        else dlg.removeAttribute('open');
      } catch {}
    }

    function cleanStr(x) {
      return (x == null) ? '' : String(x).trim();
    }

    function looksLikeYouTubeVideoId(s) {
      const x = cleanStr(s);
      return /^[a-zA-Z0-9_-]{11}$/.test(x);
    }

    function getVideoIdFromRefVideo(v) {
      const byIndent = cleanStr(v && v.indent_id);
      if (looksLikeYouTubeVideoId(byIndent)) return byIndent;
      const url = cleanStr(v && v.url);
      if (url && window.YouTubeRefVideosStore && typeof window.YouTubeRefVideosStore.extractVideoIdFromUrl === 'function') {
        const vid = cleanStr(window.YouTubeRefVideosStore.extractVideoIdFromUrl(url));
        if (vid) return vid;
      }
      // Fallback: allow indent_id even if it's not strictly 11 chars.
      return byIndent;
    }

    async function switchToVideoId(videoId) {
      const vid = cleanStr(videoId);
      if (!vid) return;

      currentVideoId = vid;
      // Persist the last selection (best-effort)
      Promise.resolve().then(() => saveLastSelectedVideoId(vid)).catch(() => {});
      transcriptRawText = '';
      setTranscript([]);

      // Update the embedded player (no new window/tab)
      try {
        if (player && typeof player.cueVideoById === 'function') player.cueVideoById(vid);
        else if (player && typeof player.loadVideoById === 'function') player.loadVideoById(vid);
      } catch {}

      // Load transcript for this videoId
      setMainStatus('Loading transcript...');
      try {
        if (!window.YouTubeTranscriptStore || typeof window.YouTubeTranscriptStore.load !== 'function') {
          setMainStatus('Transcript store not available');
          return;
        }

        const data = await window.YouTubeTranscriptStore.load(vid);
        const items = (data && Array.isArray(data.items)) ? data.items : [];
        transcriptRawText = (data && typeof data.rawText === 'string') ? data.rawText : '';
        applyTranscriptMetaFromData(data);
        if (items && items.length) {
          setTranscript(items);
          setMainStatus(`Transcript loaded: ${items.length} items`);
        } else {
          setMainStatus('No transcript loaded');
        }

        // Best-effort restore of transcript scroll position for this video.
        // Delay to ensure renderTranscript + active-row positioning have run.
        Promise.resolve().then(async () => {
          await sleepMs(0);
          await restoreTranscriptScrollPosition(vid);
        }).catch(() => {});
      } catch (err) {
        setMainStatus('Transcript load failed (check console)');
        try { console.warn('Load transcript failed', err); } catch {}
      }
    }

    async function loadRefVideos() {
      const list = document.getElementById('refVideosList');
      if (!list) return;
      list.innerHTML = '';

      if (!window.YouTubeRefVideosStore || typeof window.YouTubeRefVideosStore.listAll !== 'function') {
        setRefStatus('YouTubeRefVideosStore not available');
        return;
      }

      const all = await window.YouTubeRefVideosStore.listAll();
      const sorted = (Array.isArray(all) ? all : [])
        .filter(Boolean)
        .map(v => ({
          indent_id: String(v.indent_id || '').trim(),
          url: String(v.url || '').trim(),
          short_name: String(v.short_name || '').trim(),
          title: String(v.title || '').trim(),
          order: Number.isFinite(Number(v.order)) ? Number(v.order) : 9999
        }))
        .sort((a, b) => (a.order - b.order) || a.indent_id.localeCompare(b.indent_id));

      const top = sorted.slice(0, 5);
      if (top.length === 0) {
        const li = document.createElement('li');
        li.className = 'muted';
        li.textContent = 'No saved videos yet.';
        list.appendChild(li);
        setRefStatus('');
        return;
      }

      top.forEach(v => {
        const li = document.createElement('li');
        li.style.padding = '10px';
        li.style.border = '1px solid currentColor';
        li.style.borderRadius = '10px';
        li.style.cursor = 'pointer';
        const label = v.short_name || v.title || v.indent_id || v.url;
        li.textContent = label;
        li.onclick = () => {
          Promise.resolve().then(async () => {
            const vid = getVideoIdFromRefVideo(v);
            if (!vid) {
              setMainStatus('Bad video id');
              return;
            }
            closeDialogById('dlgMainMenu');
            await switchToVideoId(vid);
          }).catch(() => setMainStatus('Switch failed'));
        };
        list.appendChild(li);
      });
      setRefStatus('');
    }

    async function saveRefVideoFromForm() {
      if (!window.YouTubeRefVideosStore || typeof window.YouTubeRefVideosStore.save !== 'function') {
        throw new Error('YouTubeRefVideosStore not available');
      }

      const indent_id = document.getElementById('inIndentId')?.value;
      const url = document.getElementById('inUrl')?.value;
      const short_name = document.getElementById('inShortName')?.value;
      const title = document.getElementById('inTitle')?.value;
      const tag = document.getElementById('inTag')?.value;
      const order = document.getElementById('inOrder')?.value;
      const description = document.getElementById('inDesc')?.value;

      await window.YouTubeRefVideosStore.save({
        indent_id,
        url,
        short_name,
        title,
        tag,
        order,
        description
      });
    }

    function makeShortNameFromTitle(title) {
      const t = cleanStr(title);
      if (!t) return '';
      const maxLen = 40;
      if (t.length <= maxLen) return t;
      return t.slice(0, maxLen - 1).trimEnd() + '…';
    }

    async function tryAutofillFromUrl() {
      const inUrl = document.getElementById('inUrl');
      if (!inUrl) return;
      const url = cleanStr(inUrl.value);
      if (!url) return;

      const inIndent = document.getElementById('inIndentId');
      const inTitle = document.getElementById('inTitle');
      const inShort = document.getElementById('inShortName');

      // Auto-detect indent_id (videoId) if empty
      if (inIndent && !cleanStr(inIndent.value) && window.YouTubeRefVideosStore && typeof window.YouTubeRefVideosStore.extractVideoIdFromUrl === 'function') {
        const vid = cleanStr(window.YouTubeRefVideosStore.extractVideoIdFromUrl(url));
        if (vid) inIndent.value = vid;
      }

      // Only fill if user didn't already type these fields
      const needTitle = !inTitle || !cleanStr(inTitle.value);
      const needShort = !inShort || !cleanStr(inShort.value);
      if (!needTitle && !needShort) return;

      setAddVideoStatus('Autofill...');
      try {
        const oembedUrl = `https://www.youtube.com/oembed?format=json&url=${encodeURIComponent(url)}`;
        const resp = await fetch(oembedUrl, { method: 'GET' });
        if (!resp.ok) throw new Error(`oEmbed HTTP ${resp.status}`);
        const data = await resp.json();
        const title = cleanStr(data && data.title);
        if (needTitle && inTitle && title) inTitle.value = title;
        if (needShort && inShort) {
          const shortTitle = makeShortNameFromTitle(title || (inTitle ? inTitle.value : ''));
          if (shortTitle) inShort.value = shortTitle;
        }
        setAddVideoStatus('Autofill done');
      } catch (err) {
        setAddVideoStatus('Autofill failed (manual)');
        try { console.warn('oEmbed autofill failed', err); } catch {}
      }
    }

    function wireControls() {
      document.getElementById('btnPlay').onclick = () => togglePlayPause();
      document.getElementById('btnMark1').onclick = () => {
        Promise.resolve().then(() => toggleMark1OnActive()).catch(() => {});
      };

      document.getElementById('btnMrkOff').onclick = () => {
        Promise.resolve().then(() => setMark1OnActive(false)).catch(() => {});
      };

      document.getElementById('btnMenu').onclick = () => openMenuModal();
      document.getElementById('btnMenuPaste').onclick = (e) => {
        e.preventDefault();
        openPasteModal();
      };
      document.getElementById('btnMenuToggleTrans').onclick = (e) => {
        e.preventDefault();
        toggleTranscript();
        updateMenuLabels();
      };
      document.getElementById('btnMenuToggleTime').onclick = (e) => {
        e.preventDefault();
        setTimeVisible(!isTimeVisible());
        updateMenuLabels();
      };

      document.getElementById('btnApplyTrans').onclick = (e) => {
        try {
          e.preventDefault();
          const raw = document.getElementById('taTrans').value;
          const parsed = parseTranscriptText(raw);
          transcriptRawText = raw;
          const items = mergeTranscriptLanguage(transcript, parsed, langEdit);
          setTranscript(items);
          setStatus(`Applied (${langEdit.toUpperCase()}): ${parsed.length} items`);
        } catch (err) {
          setStatus('Parse failed');
        }
      };

      document.getElementById('btnSaveTrans').onclick = async (e) => {
        e.preventDefault();
        try {
          const raw = document.getElementById('taTrans').value;
          const parsed = parseTranscriptText(raw);
          transcriptRawText = raw;
          const items = mergeTranscriptLanguage(transcript, parsed, langEdit);
          setTranscript(items);
          setStatus('Saving...');
          await saveTranscriptToFirebase(raw, items);
          setStatus(`Saved (${langEdit.toUpperCase()}): ${parsed.length} items`);
        } catch (err) {
          setStatus('Save failed (check console)');
          try { console.warn('Save transcript failed', err); } catch {}
        }
      };

      // time + highlight loop
      setInterval(() => {
        if (!player || typeof player.getCurrentTime !== 'function') return;
        const t = player.getCurrentTime();
        // Keep seconds precision for the main time indicator (not the transcript timestamps)
        if (isTimeVisible()) {
          try { document.getElementById('t').textContent = Number(t || 0).toFixed(2); } catch {}
        }

        const wrap = document.getElementById('transWrap');
        const isShown = wrap.style.display === 'block';
        if (!isShown) return;

        const idx = findActiveByTime(t);
        if (idx !== activeIndex) {
          activeIndex = idx;
          updateActiveRow();
        }
      }, 250);

      // Persist transcript scroll position (best-effort; no more often than every 30s).
      setInterval(() => {
        Promise.resolve().then(() => saveTranscriptScrollPosition()).catch(() => {});
      }, 5000);

      // On startup: load last-selected videoId from Firebase (optional), else keep default.
      Promise.resolve().then(async () => {
        const lastVid = await loadLastSelectedVideoId();
        if (lastVid && lastVid !== currentVideoId) {
          await switchToVideoId(lastVid);
          return;
        }
        await tryLoadTranscriptFromFirebase();

        // Best-effort restore of scroll for the default/current video.
        await restoreTranscriptScrollPosition(currentVideoId);
      }).catch(() => {
        Promise.resolve().then(() => tryLoadTranscriptFromFirebase()).catch(() => {});
      });

      // Defaults from spec
      setTimeVisible(false);
      setTranscriptVisible(true);
      updateMenuLabels();

      // Main menu (reference videos)
      const btnMain = document.getElementById('btnMainMenu');
      if (btnMain) btnMain.onclick = () => openMainMenu();

      const btnAdd = document.getElementById('btnAddVideo');
      if (btnAdd) btnAdd.onclick = (e) => { e.preventDefault(); openAddVideoDialog(); };

      const btnSaveVid = document.getElementById('btnSaveVideo');
      if (btnSaveVid) btnSaveVid.onclick = async (e) => {
        e.preventDefault();
        try {
          setAddVideoStatus('Saving...');
          await saveRefVideoFromForm();
          setAddVideoStatus('Saved');
          // Refresh list if menu is open
          Promise.resolve().then(() => loadRefVideos()).catch(() => {});
        } catch (err) {
          setAddVideoStatus('Save failed (check console)');
          try { console.warn('Save ref video failed', err); } catch {}
        }
      };

      // Autofill when user leaves the URL field (switches to another field)
      const inUrl = document.getElementById('inUrl');
      if (inUrl) {
        inUrl.addEventListener('blur', () => {
          Promise.resolve().then(() => tryAutofillFromUrl()).catch(() => {});
        });
      }
    }

    // 2) Load YouTube iframe
    window.onYouTubeIframeAPIReady = function () {
      player = new YT.Player('player', {
        videoId: currentVideoId,
        playerVars: { rel: 0, modestbranding: 1, origin: location.origin },
        events: {
          onReady: () => {
            wireControls();
          },
          onStateChange: (e) => {
            try {
              // 1 = playing
              isPlaying = (e && e.data === 1);
              updatePlayButtonLabel();
            } catch {}
          }
        }
      });
    };
  </script>
</body>
</html>
