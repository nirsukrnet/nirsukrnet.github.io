<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Librosa Debug Viewer (Real Data)</title>
    <style>
        body { font-family: sans-serif; padding: 20px; max-width: 95%; margin: 0 auto; }
        .control-group { margin-bottom: 20px; padding: 15px; background: #f5f5f5; border-radius: 8px; display: flex; gap: 20px; align-items: center; }
        
        label { font-weight: bold; margin-right: 5px; }
        button { padding: 8px 16px; cursor: pointer; font-size: 16px; background: #333; color: #fff; border: none; border-radius: 4px; }
        button:hover { background: #555; }

        .timeline-container { margin-bottom: 30px; overflow-x: auto; border: 1px solid #ccc; background: #fff; }
        .timeline-label { font-weight: bold; margin-bottom: 5px; display: flex; justify-content: space-between; padding: 5px; background: #eee; position: sticky; left: 0; }
        
        /* Wrapper for scrolling content */
        .timeline-scroll-area { position: relative; height: 80px; background: #fafafa; }
        
        canvas { height: 100%; display: block; position: absolute; top: 0; left: 0; }
        
        .ruler { position: absolute; bottom: 0; left: 0; width: 100%; height: 20px; font-size: 10px; color: #666; pointer-events: none; }
        .ruler-mark { position: absolute; bottom: 0; border-left: 1px solid #ccc; height: 5px; padding-left: 2px; }

        .legend { font-size: 12px; color: #666; }
        .legend span { display: inline-block; width: 12px; height: 12px; margin-right: 5px; vertical-align: middle; }

        #detailsPanel {
            margin-top: 20px;
            padding: 15px;
            border: 1px solid #ccc;
            background: #f9f9f9;
            min-height: 100px;
            font-family: monospace;
            white-space: pre-wrap;
        }
    </style>
</head>
<body>
    <h1>Librosa Debug Viewer (Real Data)</h1>
    <p>Load the JSON file generated by <code>librosa_format_item.py</code> to visualize the processing pipeline.</p>

    <div class="control-group">
        <div>
            <label for="fileInput">Load JSON File:</label>
            <input type="file" id="fileInput" accept=".json">
        </div>
        <div id="fileInfo" style="font-style: italic; color: #666;">No file loaded</div>
        <div id="configInfo" style="margin-left: auto; font-family: monospace; font-size: 14px; background: #e0e0e0; padding: 5px 10px; border-radius: 4px; display: none;">
            <!-- Config values will be inserted here -->
        </div>
    </div>

    <div id="visualizationArea" style="display: none;">
        
        <!-- Layer 1: Raw -->
        <div class="timeline-label">
            <span>Layer 1: Raw Detection</span>
            <span class="legend"><span style="background: rgba(0, 0, 255, 0.5);"></span>Raw Intervals</span>
        </div>
        <div class="timeline-container">
            <div class="timeline-scroll-area" id="scrollAreaRaw">
                <canvas id="canvasRaw"></canvas>
                <div class="ruler" id="rulerRaw"></div>
            </div>
        </div>

        <!-- Layer 2: Merged -->
        <div class="timeline-label">
            <span>Layer 2: Merged</span>
            <span class="legend"><span style="background: rgba(128, 0, 128, 0.5);"></span>Merged Intervals</span>
        </div>
        <div class="timeline-container">
            <div class="timeline-scroll-area" id="scrollAreaMerged">
                <canvas id="canvasMerged"></canvas>
                <div class="ruler" id="rulerMerged"></div>
            </div>
        </div>

        <!-- Layer 3: Rejected -->
        <div class="timeline-label">
            <span>Layer 3: Rejected (Marked Silence)</span>
            <span class="legend"><span style="background: rgba(255, 0, 0, 0.5);"></span>Rejected Intervals</span>
        </div>
        <div class="timeline-container">
            <div class="timeline-scroll-area" id="scrollAreaRejected">
                <canvas id="canvasRejected"></canvas>
                <div class="ruler" id="rulerRejected"></div>
            </div>
        </div>

        <!-- Layer 4: Final -->
        <div class="timeline-label">
            <span>Layer 4: Final Output</span>
            <span class="legend"><span style="background: rgba(0, 128, 0, 0.5);"></span>Final Sound</span>
        </div>
        <div class="timeline-container">
            <div class="timeline-scroll-area" id="scrollAreaFinal">
                <canvas id="canvasFinal"></canvas>
                <div class="ruler" id="rulerFinal"></div>
            </div>
        </div>

        <h3>Selected Interval Details</h3>
        <div id="detailsPanel">Click on an interval to see details...</div>
    </div>

    <script>
        // ==========================================
        // STATE
        // ==========================================
        let appData = null;
        const PIXELS_PER_SECOND = 100; // Zoom level

        // ==========================================
        // DATA PARSING
        // ==========================================

        function parseCompactData(schema, rows) {
            if (!rows || !schema) return [];
            return rows.map(row => {
                let obj = {};
                schema.forEach((key, index) => {
                    obj[key] = row[index];
                });
                return obj;
            });
        }

        function loadData(json) {
            try {
                const meta = json.meta;
                const data = json.data;
                
                // Parse Raw
                const rawIntervals = parseCompactData(meta.sound_intervals_raw_schema, data.sound_intervals_raw);
                
                // Parse Merged (Schema is implicit: [ids, start, end])
                const mergedIntervals = data.sound_intervals_merged.map(row => ({
                    ids: row[0],
                    start: row[1],
                    end: row[2]
                }));

                // Parse Rejected (Schema implicit: [ids, start, end, reason])
                const rejectedIntervals = data.marked_silence.map(row => ({
                    ids: row[0],
                    start: row[1],
                    end: row[2],
                    reason: row[3]
                }));

                // Parse Final (Schema implicit: [start, end, type])
                const finalIntervals = data.final_intervals.map(row => ({
                    start: row[0],
                    end: row[1],
                    type: row[2]
                }));

                // Calculate total duration from final interval or config
                let duration = 0;
                if (finalIntervals.length > 0) {
                    duration = finalIntervals[finalIntervals.length - 1].end;
                }
                // Or try to get from config if available (not in current JSON spec but good practice)
                
                appData = {
                    raw: rawIntervals,
                    merged: mergedIntervals,
                    rejected: rejectedIntervals,
                    final: finalIntervals,
                    duration: duration,
                    config: json.config
                };

                document.getElementById('fileInfo').innerText = `Loaded: ${rawIntervals.length} raw intervals. Duration: ${duration.toFixed(2)}s`;
                
                // Display Config
                if (json.config) {
                    const configDiv = document.getElementById('configInfo');
                    configDiv.style.display = 'block';
                    configDiv.innerHTML = `
                        <strong>Config:</strong> 
                        join_if_dist: <span style="color: blue">${json.config.join_if_dist}</span>, 
                        min_duration_sec: <span style="color: blue">${json.config.min_duration_sec}</span>
                    `;
                }

                document.getElementById('visualizationArea').style.display = 'block';
                
                renderAll();

            } catch (e) {
                console.error(e);
                alert("Error parsing JSON: " + e.message);
            }
        }

        // ==========================================
        // VISUALIZATION
        // ==========================================

        function setupCanvas(canvasId, containerId, duration) {
            const canvas = document.getElementById(canvasId);
            const container = document.getElementById(containerId);
            
            const width = Math.ceil(duration * PIXELS_PER_SECOND);
            const height = container.clientHeight;
            
            // Set CSS size
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            container.style.width = width + 'px'; // Expand scroll area

            // Set logical size for High DPI
            const dpr = window.devicePixelRatio || 1;
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            
            const ctx = canvas.getContext('2d');
            ctx.scale(dpr, dpr);
            
            return { ctx, width, height };
        }

        let selectedSelection = null; // { start, end, layer }

        function drawTimeline(canvasId, containerId, intervals, color, type) {
            if (!appData) return;
            
            const { ctx, width, height } = setupCanvas(canvasId, containerId, appData.duration);
            
            // Clear
            ctx.clearRect(0, 0, width, height);

            // Draw Intervals
            intervals.forEach(interval => {
                // Filter for Final layer (only draw sound=1)
                if (type === 'final' && interval.type === 0) return;

                const start = interval.start;
                const end = interval.end;
                
                const x = start * PIXELS_PER_SECOND;
                const w = (end - start) * PIXELS_PER_SECOND;
                
                ctx.fillStyle = color;
                ctx.fillRect(x, 0, w, height);
                
                // Border
                ctx.strokeStyle = 'rgba(0,0,0,0.2)';
                ctx.strokeRect(x, 0, w, height);

                // Label (if wide enough)
                if (w > 20) {
                    ctx.fillStyle = '#000';
                    ctx.font = '10px sans-serif';
                    if (interval.id) {
                        ctx.fillText(interval.id, x + 2, 12);
                    }
                }
            });

            // Draw Selection Highlight
            if (selectedSelection && selectedSelection.layer === type) {
                const s = selectedSelection.start * PIXELS_PER_SECOND;
                const e = selectedSelection.end * PIXELS_PER_SECOND;
                const w = e - s;
                
                ctx.fillStyle = 'rgba(255, 255, 0, 0.4)'; // Yellow highlight
                ctx.fillRect(s, 0, w, height);
                ctx.strokeStyle = '#ffff00';
                ctx.lineWidth = 2;
                ctx.strokeRect(s, 0, w, height);
            }

            // Draw Ruler
            const rulerId = containerId.replace('scrollArea', 'ruler');
            drawRuler(rulerId, appData.duration);
        }

        function drawRuler(rulerId, duration) {
            const container = document.getElementById(rulerId);
            container.innerHTML = '';
            
            // Mark every second
            for (let i = 0; i <= duration; i++) {
                const mark = document.createElement('div');
                mark.className = 'ruler-mark';
                mark.style.left = (i * PIXELS_PER_SECOND) + 'px';
                if (i % 5 === 0) {
                    mark.innerText = i + 's';
                    mark.style.height = '10px';
                    mark.style.fontWeight = 'bold';
                }
                container.appendChild(mark);
            }
        }

        function renderAll() {
            if (!appData) return;

            drawTimeline('canvasRaw', 'scrollAreaRaw', appData.raw, 'rgba(0, 0, 255, 0.5)', 'raw');
            drawTimeline('canvasMerged', 'scrollAreaMerged', appData.merged, 'rgba(128, 0, 128, 0.5)', 'merged');
            drawTimeline('canvasRejected', 'scrollAreaRejected', appData.rejected, 'rgba(255, 0, 0, 0.5)', 'rejected');
            drawTimeline('canvasFinal', 'scrollAreaFinal', appData.final, 'rgba(0, 128, 0, 0.5)', 'final');
        }

        // ==========================================
        // SYNCHRONIZATION
        // ==========================================
        
        const scrollContainers = [
            document.querySelector('#scrollAreaRaw').parentElement,
            document.querySelector('#scrollAreaMerged').parentElement,
            document.querySelector('#scrollAreaRejected').parentElement,
            document.querySelector('#scrollAreaFinal').parentElement
        ];

        let isSyncing = false;

        scrollContainers.forEach(container => {
            container.addEventListener('scroll', function(e) {
                if (isSyncing) return;
                isSyncing = true;
                
                const scrollLeft = e.target.scrollLeft;
                
                scrollContainers.forEach(other => {
                    if (other !== e.target) {
                        other.scrollLeft = scrollLeft;
                    }
                });
                
                isSyncing = false;
            });
        });

        // ==========================================
        // INTERACTION
        // ==========================================

        document.getElementById('fileInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const json = JSON.parse(e.target.result);
                    loadData(json);
                } catch (err) {
                    alert("Invalid JSON file");
                }
            };
            reader.readAsText(file);
        });

        // Click Handler Logic (Generic for all canvases)
        function handleCanvasClick(e, type) {
            if (!appData) return;
            
            // e.offsetX is relative to the target element (canvas).
            const clickX = e.offsetX;
            const clickTime = clickX / PIXELS_PER_SECOND;

            let dataset = [];
            
            if (type === 'raw') dataset = appData.raw;
            else if (type === 'merged') dataset = appData.merged;
            else if (type === 'rejected') dataset = appData.rejected;
            else if (type === 'final') dataset = appData.final;

            // 1. Try to find explicit interval
            let found = dataset.find(i => clickTime >= i.start && clickTime <= i.end);
            let isGap = false;

            // 2. If not found, check for gap (Silence)
            if (!found) {
                // Logic to find gap
                let prev = null;
                let next = null;
                
                for (let i = 0; i < dataset.length; i++) {
                    if (dataset[i].start > clickTime) {
                        next = dataset[i];
                        break;
                    }
                    prev = dataset[i];
                }
                
                let start = prev ? prev.end : 0;
                let end = next ? next.start : appData.duration;
                
                if (clickTime >= start && clickTime <= end) {
                    found = { start: start, end: end, type: 'silence (gap)' };
                    isGap = true;
                }
            }

            const panel = document.getElementById('detailsPanel');
            if (found) {
                // Update Selection State
                selectedSelection = {
                    start: found.start,
                    end: found.end,
                    layer: type
                };

                panel.innerText = `Layer: ${type.toUpperCase()}\n` + 
                                  `Type: ${isGap ? 'SILENCE (Gap)' : (found.type === 0 ? 'SILENCE (Explicit)' : 'SOUND')}\n` +
                                  `Time: ${found.start.toFixed(3)}s - ${found.end.toFixed(3)}s\n` +
                                  `Duration: ${(found.end - found.start).toFixed(3)}s\n\n` +
                                  `Data:\n${JSON.stringify(found, null, 2)}`;
                
                renderAll(); // Redraw to show highlight
            } else {
                selectedSelection = null;
                renderAll();
                panel.innerText = `Clicked at ${clickTime.toFixed(3)}s (No interval found in ${type} layer)`;
            }
        }

        document.getElementById('canvasRaw').addEventListener('click', (e) => handleCanvasClick(e, 'raw'));
        document.getElementById('canvasMerged').addEventListener('click', (e) => handleCanvasClick(e, 'merged'));
        document.getElementById('canvasRejected').addEventListener('click', (e) => handleCanvasClick(e, 'rejected'));
        document.getElementById('canvasFinal').addEventListener('click', (e) => handleCanvasClick(e, 'final'));

    </script>
</body>
</html>